//! Random source generator used by fuzzing, perf, and tests.
//!
//! Notes:
//! - Generates *at least* `target_len` bytes (may overshoot a bit).
//! - Always appends a safe trailer to keep EOF and block comments well-formed.

use rand::Rng;

/// Appended to every generated string to keep block-comments closed and
/// ensure a clean EOF tokenization boundary.
///
/// NOTE:
/// - The leading space prevents accidentally creating `"/*"` if the last
///   generated byte was `'/'`.
/// - The `*/` still appears contiguously to close any open block comment.
/// - The `" 0\n"` gives a simple token and a hard newline at EOF.
pub const SAFE_TRAILER: &str = " */ 0\n";

/// Generate a random, lexically valid source string that is **at least**
/// `target_len` bytes long (plus a short, safe trailer).
///
/// This is the same strategy used in the fuzz/perf binaries.
pub fn gen_valid_source<R: Rng>(rng: &mut R, target_len: usize) -> String {
    let mut out = String::with_capacity(target_len + target_len / 8);

    while out.len() < target_len {
        let roll = rng.random_range(0u32..100);
        match roll {
            0..=24 => push_ident(rng, &mut out),
            25..=39 => push_int(rng, &mut out),
            40..=54 => push_ws(rng, &mut out),
            55..=61 => push_line_comment(rng, &mut out),
            62..=70 => push_block_comment(rng, &mut out),
            71..=99 => push_operator(rng, &mut out),
            _ => unreachable!(),
        }
    }

    // Trailer keeps the last block-comment sane and ensures an EOF tokenization edge.
    out.push_str(SAFE_TRAILER);
    out
}

fn push_ident<R: Rng>(rng: &mut R, out: &mut String) {
    let len = rng.random_range(1..=12);
    let mut s = String::new();
    s.push(random_alpha(rng));
    for _ in 1..len {
        if rng.random_bool(0.6) {
            s.push(random_alpha(rng));
        } else {
            s.push(random_digit(rng));
        }
    }
    out.push_str(&s);
}

fn push_int<R: Rng>(rng: &mut R, out: &mut String) {
    let len = rng.random_range(1..=8);
    for _ in 0..len {
        out.push(random_digit(rng));
    }
}

fn push_ws<R: Rng>(rng: &mut R, out: &mut String) {
    let opts: [char; 4] = [' ', '\t', '\r', '\n'];
    let len = rng.random_range(1..=8);
    for _ in 0..len {
        let i = rng.random_range(0..opts.len());
        out.push(opts[i]);
    }
}

fn push_line_comment<R: Rng>(rng: &mut R, out: &mut String) {
    out.push_str("//");
    let len = rng.random_range(0..=40);
    const ALPH: &str =
        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 +-*/&|![]{}()<>=*";
    let bytes = ALPH.as_bytes();
    for _ in 0..len {
        let i = rng.random_range(0..bytes.len());
        out.push(bytes[i] as char);
    }
    out.push('\n');
}

fn push_block_comment<R: Rng>(rng: &mut R, out: &mut String) {
    out.push_str("/*");
    let chunks = rng.random_range(0..=15);
    const BODY: &str =
        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 +-![]{}()<>=&|";
    let bytes = BODY.as_bytes();
    for _ in 0..chunks {
        let k = rng.random_range(1..=8);
        for _ in 0..k {
            let i = rng.random_range(0..bytes.len());
            out.push(bytes[i] as char);
        }
        if rng.random_bool(0.2) {
            out.push('*');
        }
        if rng.random_bool(0.2) {
            out.push('\n');
        }
    }
    out.push_str("*/");
}

fn push_operator<R: Rng>(rng: &mut R, out: &mut String) {
    let ops = [
        "(", ")", "+", "*", "=", "/", "!", "[", "]", "{", "}", "<", "<=", ">", ">=", "==", "&",
        "&&", "|", "||",
    ];
    let i = rng.random_range(0..ops.len());
    out.push_str(ops[i]);
    if rng.random_bool(0.25) {
        out.push(' ');
    }
}

fn random_alpha<R: Rng>(rng: &mut R) -> char {
    let set = b"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_";
    let i = rng.random_range(0..set.len());
    set[i] as char
}

fn random_digit<R: Rng>(rng: &mut R) -> char {
    let set = b"0123456789";
    let i = rng.random_range(0..set.len());
    set[i] as char
}

#[test]
fn trailer_never_opens_comment_after_slash() {
    let s = String::from("/") + SAFE_TRAILER;
    assert!(
        !s.contains("/*"),
        "trailer must not create /* across the boundary"
    );
}

#[test]
fn trailer_can_close_open_comment() {
    let s = String::from("/*") + SAFE_TRAILER;
    assert!(
        s.contains("*/"),
        "trailer should contain a contiguous */ to close"
    );
}
